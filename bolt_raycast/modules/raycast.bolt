from contextlib import contextmanager
from math import ceil
from bolt_raycast.enums import DistanceType

class RayStep:
    potentially_hit = False

    def __init__(self, parent, tag, objective, step_size):
        self._parent = parent
        self._tag = tag
        self._objective = objective
        self._step_size = step_size

class Ray:
    def __init__(self, parent, tag, objective, step_size, steps):
        self._parent = parent
        self._tag = tag
        self._objective = objective
        self._step_size = step_size
        self._steps = steps
    
    def __iter__(self):
        name = f"{self._parent}/step"
        step = RayStep(self._parent, self._tag, self._objective, self._step_size)
        execute function name:
            yield step
            scoreboard players add #distance self._objective 1

            def recurse():
                execute
                    if score #distance self._objective matches (None, self._steps)
                    positioned ^ ^ ^self._step_size
                    function name

            if step.potentially_hit:
                if score #hit self._objective matches 0:
                    recurse()
            else:
                recurse()

used_objectives = set()
load_func = generate_path()
added_load = False

def create_objective(objective):
    if objective not in used_objectives:
        used_objectives.add(objective)
        global added_load
        if not added_load:
            added_load = True
            prepend function_tag minecraft:load {"values": [load_func]}
        
        append function load_func:
            scoreboard objectives add objective dummy

@contextmanager
def raycast(*,
    parent = None,                           # : str | None
    tag = "bolt_raycast.source",             # : str | None
    objective = "bolt_raycast.temp",         # : str
    step_size = 0.1,                         # : float
    max_distance = (10, DistanceType.Blocks) # : tuple[float, DistanceType]
    ):
    create_objective(objective)

    name_spec = "raycast_{incr}"
    if parent is None or len(parent) == 0:
        parent = generate_path(name_spec)
    else:
        if not parent.endswith("/"):
            parent = parent + "/"
            
        with ctx.override(generate_path = parent) as no_prefix:
            parent = no_prefix.generate.path(name_spec)

    if max_distance[1] == DistanceType.Blocks:
        steps = ceil(max_distance[0] / step_size)
    else:
        steps = max_distance[0]

    if tag is not None:
        tag @s add tag
    
    scoreboard players set #hit objective 0
    scoreboard players set #distance objective 0
    
    yield Ray(parent, tag, objective, step_size, steps)

    if tag is not None:
        tag @s remove tag